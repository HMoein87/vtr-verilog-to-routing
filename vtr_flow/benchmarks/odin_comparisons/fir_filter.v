// megafunction wizard: %LPM_MULT%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: lpm_mult

// ============================================================
// File Name: lpm_mult0.v
// Megafunction Name(s):
// 			lpm_mult
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 4.1 Build 181 06/29/2004 SJ Full Version
// ************************************************************


//Copyright (C) 1991-2004 Altera Corporation
//Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
//support information,  device programming or simulation file,  and any other
//associated  documentation or information  provided by  Altera  or a partner
//under  Altera's   Megafunction   Partnership   Program  may  be  used  only
//to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
//other  use  of such  megafunction  design,  netlist,  support  information,
//device programming or simulation file,  or any other  related documentation
//or information  is prohibited  for  any  other purpose,  including, but not
//limited to  modification,  reverse engineering,  de-compiling, or use  with
//any other  silicon devices,  unless such use is  explicitly  licensed under
//a separate agreement with  Altera  or a megafunction partner.  Title to the
//intellectual property,  including patents,  copyrights,  trademarks,  trade
//secrets,  or maskworks,  embodied in any such megafunction design, netlist,
//support  information,  device programming or simulation file,  or any other
//related documentation or information provided by  Altera  or a megafunction
//partner, remains with Altera, the megafunction partner, or their respective
//licensors. No other licenses, including any licenses needed under any third
//party's intellectual property, are provided herein.


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module lpm_mult0 (
	dataa,
	datab,
	clock,
	result);

	input	[7:0]  dataa;
	input	[7:0]  datab;
	input	  clock;
	output	[15:0]  result;
	reg[15:0] pipeline1;
	reg[15:0] pipeline2;

	always @(posedge clock)
	begin
	    result = pipeline2;
	    pipeline2 = pipeline1;
	    pipeline1 = dataa * datab;
	end

	/*lpm_mult	lpm_mult_component (
				.dataa (dataa),
				.datab (datab),
				.clock (clock),
				.result (sub_wire0),
				.clken (1'b1),
				.sum (1'b0),
				.aclr (1'b0));
	defparam
		lpm_mult_component.lpm_widtha = 8,
		lpm_mult_component.lpm_widthb = 8,
		lpm_mult_component.lpm_widthp = 16,
		lpm_mult_component.lpm_widths = 1,
		lpm_mult_component.lpm_type = "LPM_MULT",
		lpm_mult_component.lpm_representation = "UNSIGNED",
		lpm_mult_component.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=5",
		lpm_mult_component.lpm_pipeline = 3;*/


endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: WidthA NUMERIC "8"
// Retrieval info: PRIVATE: WidthB NUMERIC "8"
// Retrieval info: PRIVATE: WidthS NUMERIC "1"
// Retrieval info: PRIVATE: WidthP NUMERIC "16"
// Retrieval info: PRIVATE: OptionalSum NUMERIC "0"
// Retrieval info: PRIVATE: AutoSizeResult NUMERIC "1"
// Retrieval info: PRIVATE: B_isConstant NUMERIC "0"
// Retrieval info: PRIVATE: SignedMult NUMERIC "0"
// Retrieval info: PRIVATE: ConstantB NUMERIC "0"
// Retrieval info: PRIVATE: ValidConstant NUMERIC "0"
// Retrieval info: PRIVATE: Latency NUMERIC "1"
// Retrieval info: PRIVATE: aclr NUMERIC "0"
// Retrieval info: PRIVATE: clken NUMERIC "0"
// Retrieval info: PRIVATE: LPM_PIPELINE NUMERIC "3"
// Retrieval info: PRIVATE: optimize NUMERIC "0"
// Retrieval info: CONSTANT: LPM_WIDTHA NUMERIC "8"
// Retrieval info: CONSTANT: LPM_WIDTHB NUMERIC "8"
// Retrieval info: CONSTANT: LPM_WIDTHP NUMERIC "16"
// Retrieval info: CONSTANT: LPM_WIDTHS NUMERIC "1"
// Retrieval info: CONSTANT: LPM_TYPE STRING "LPM_MULT"
// Retrieval info: CONSTANT: LPM_REPRESENTATION STRING "UNSIGNED"
// Retrieval info: CONSTANT: LPM_HINT STRING "DEDICATED_MULTIPLIER_CIRCUITRY=YES,MAXIMIZE_SPEED=5"
// Retrieval info: CONSTANT: LPM_PIPELINE NUMERIC "3"
// Retrieval info: USED_PORT: dataa 0 0 8 0 INPUT NODEFVAL dataa[7..0]
// Retrieval info: USED_PORT: result 0 0 16 0 OUTPUT NODEFVAL result[15..0]
// Retrieval info: USED_PORT: datab 0 0 8 0 INPUT NODEFVAL datab[7..0]
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL clock
// Retrieval info: CONNECT: @dataa 0 0 8 0 dataa 0 0 8 0
// Retrieval info: CONNECT: result 0 0 16 0 @result 0 0 16 0
// Retrieval info: CONNECT: @datab 0 0 8 0 datab 0 0 8 0
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: LIBRARY: lpm lpm.lpm_components.all
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0.inc FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0.cmp FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0.bsf FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0_inst.v FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0_bb.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0_waveforms.html TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL lpm_mult0_wave*.jpg FALSE
//Fir_Filter Behavioral Model
//Jonathan Allen
//ECE 659 HW#1
module fir_filter(
	clk,
	reset,
	data_in,
	data_out,
	coef_in,
	load_c
);
parameter TAPS = 25;
//Input Ports
input clk;
input reset;
input [7:0] data_in;
input [7:0] coef_in;
input load_c;

//Output Ports
output [17:0] data_out;

//Data Type Declarations for IO
wire clk;
wire reset;
wire [7:0] data_in;
wire [7:0] coef_in;
wire load_c;
reg [17:0] temp;

reg [17:0] data_out;

//Other Declarations
reg [7:0] r_storage [TAPS-1:0];
reg [7:0] coef_storage [TAPS-1:0];
reg[32:0] i;
reg [15:0] product_array [TAPS-1:0];

lpm_mult0 m0(r_storage[0],coef_storage[0],clk,product_array[0]);
lpm_mult0 m1(r_storage[1],coef_storage[1],clk,product_array[1]);
lpm_mult0 m2(r_storage[2],coef_storage[2],clk,product_array[2]);
lpm_mult0 m3(r_storage[3],coef_storage[3],clk,product_array[3]);
lpm_mult0 m4(r_storage[4],coef_storage[4],clk,product_array[4]);
lpm_mult0 m5(r_storage[5],coef_storage[5],clk,product_array[5]);
lpm_mult0 m6(r_storage[6],coef_storage[6],clk,product_array[6]);
lpm_mult0 m7(r_storage[7],coef_storage[7],clk,product_array[7]);
lpm_mult0 m8(r_storage[8],coef_storage[8],clk,product_array[8]);
lpm_mult0 m9(r_storage[9],coef_storage[9],clk,product_array[9]);
lpm_mult0 m10(r_storage[10],coef_storage[10],clk,product_array[10]);
lpm_mult0 m11(r_storage[11],coef_storage[11],clk,product_array[11]);
lpm_mult0 m12(r_storage[12],coef_storage[12],clk,product_array[12]);
lpm_mult0 m13(r_storage[13],coef_storage[13],clk,product_array[13]);
lpm_mult0 m14(r_storage[14],coef_storage[14],clk,product_array[14]);
lpm_mult0 m15(r_storage[15],coef_storage[15],clk,product_array[15]);
lpm_mult0 m16(r_storage[16],coef_storage[16],clk,product_array[16]);
lpm_mult0 m17(r_storage[17],coef_storage[17],clk,product_array[17]);
lpm_mult0 m18(r_storage[18],coef_storage[18],clk,product_array[18]);
lpm_mult0 m19(r_storage[19],coef_storage[19],clk,product_array[19]);
lpm_mult0 m20(r_storage[20],coef_storage[20],clk,product_array[20]);
lpm_mult0 m21(r_storage[21],coef_storage[21],clk,product_array[21]);
lpm_mult0 m22(r_storage[22],coef_storage[22],clk,product_array[22]);
lpm_mult0 m23(r_storage[23],coef_storage[23],clk,product_array[23]);
lpm_mult0 m24(r_storage[24],coef_storage[24],clk,product_array[24]);

//par_add0 parallel_add(product_array[0],product_array[1],product_array[2],product_array[3],data_out);


//Code starts here
always @ (posedge clk)
begin

	if(reset==1'b1)begin		//reset

		for(i=0;i<TAPS;i=i+1)begin
			r_storage[i]<= 8'b00000000;
			coef_storage[i]<=8'b00000000;
		end
	end
	else if(load_c==1'b1)begin	//load coeficients
		for(i=24;i>0;i=i-1)begin
			coef_storage[i] = coef_storage[i-1];
		end
		coef_storage[0]=coef_in;
	end
	else begin
		for(i=24;i>0;i=i-1)begin
			r_storage[i] = r_storage[i-1];
		end
		r_storage[0]=data_in;
		temp=0;
		for(i=0;i<TAPS;i=i+1)begin
			temp=temp+product_array[i];
		end
		data_out=temp;
	end
end
endmodule